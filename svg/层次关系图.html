<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<h1 id="title"> </h1>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="800" viewBox="0 0 1600 1600">
</svg>
<script src="https://cdn.jsdelivr.net/npm/d3-hierarchy@3"></script>
<script>
    var data = {
        "name":"中国",
        "children": [
            { "name":"浙江" , "children": [ {"name":"杭州" }, {"name":"宁波" }, {"name":"温州" }, {"name":"绍兴" }]},
            { "name":"广西" , "children": [ {"name":"桂林"}, {"name":"南宁"}]}
        ]
    }
    //把数据转换成图形信息
    const regions = d3.hierarchy(data)
        .sum(d => 1)
        .sort((a, b) => b.value - a.value); //将省份数据按照包含城市的数量，从多到少排序

    const pack = d3.pack()
        .size([1600, 1600]) //将数据映射为一组 1600 宽高范围内的圆形
        .padding(3); //在每个相邻的圆之间我们还保留 3 个像素的 padding（

    const root = pack(regions);

    //遍历数据并且根据数据内容绘制圆弧
    const svgroot = document.querySelector('svg');

    function draw(parent, node, {fillStyle = 'rgba(0, 0, 0, 0.2)', textColor = 'white'} = {}) {
        const children = node.children;
        const {x, y, r} = node;
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', x);
        circle.setAttribute('cy', y);
        circle.setAttribute('r', r);
        circle.setAttribute('fill', fillStyle);
        circle.setAttribute('data-name', node.data.name);
        parent.appendChild(circle);
        if(children) {
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            for(let i = 0; i < children.length; i++) {
                draw(group, children[i], {fillStyle, textColor});
            }
            group.setAttribute('data-name', node.data.name);
            parent.appendChild(group);
        } else {
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('fill', textColor);
            text.setAttribute('font-family', 'Arial');
            text.setAttribute('font-size', '1.5rem');
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('x', x);
            text.setAttribute('y', y);
            const name = node.data.name;
            text.textContent = name;
            parent.appendChild(text);
        }
    }

    draw(svgroot, root);

    const titleEl = document.getElementById('title');
    function getTitle(target) {
        const name = target.getAttribute('data-name');
        if(target.parentNode && target.parentNode.nodeName === 'g') {
            const parentName = target.parentNode.getAttribute('data-name');
            return `${parentName}-${name}`;
        }
        return name;
    }

    let activeTarget = null;
    svgroot.addEventListener('mousemove', (evt) => {
        let target = evt.target;
        if(target.nodeName === 'text') target = target.previousSibling;
        if(activeTarget !== target) {
            if(activeTarget) activeTarget.setAttribute('fill', 'rgba(0, 0, 0, 0.2)');
        }
        target.setAttribute('fill', 'rgba(0, 128, 0, 0.1)');
        titleEl.textContent = getTitle(target);
        activeTarget = target;
    });
</script>
</body>
</html>